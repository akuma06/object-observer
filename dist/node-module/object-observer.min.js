const e=new WeakMap,t=new WeakMap,o=new WeakMap,r={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0};function n(e){return r.hasOwnProperty(e.constructor.name)}function l(r,n){let l,a=t.get(r),p=o.get(a.root);return l="pop"===n?function(){let o,l,f;o=r.length-1,l=Reflect.apply(r[n],r,arguments),(f=e.get(l))&&(t.get(f).revoke(),l=f);let i,s=a.path,y=s.length,c=new Array(y+1);for(i=0;i<y;i++)c[i]=s[i];return c[y]=o,p.notify([{type:"delete",path:c,oldValue:l}]),l}:"push"===n?function(){let e,t,o,l,i=arguments.length,s=new Array(i),y=[],c=a.path,h=c.length;t=r.length;for(let e,r=0;r<i;r++){for((e=arguments[r])&&"object"==typeof e&&(e=new f(e,t+r,a).proxy),s[r]=e,l=new Array(h+1),o=0;o<h;o++)l[r]=c[o];l[h]=t+r,y[r]={type:"insert",path:l,value:e}}return e=Reflect.apply(r[n],r,s),p.notify(y),e}:"shift"===n?function(){let o,l;o=Reflect.apply(r[n],r,arguments),(l=e.get(o))&&(t.get(l).revoke(),o=l);for(let o,n,l=0,a=r.length;l<a;l++)(o=r[l])&&"object"==typeof o&&((n=t.get(e.get(o)))?n.ownKey=l:console.error("unexpectedly failed to resolve proxy -> target -> observed"));return p.notify([{type:"delete",path:a.path.concat(0),oldValue:o}]),o}:"unshift"===n?function(){let o,l,i,s=[];(o=Array.from(arguments)).forEach((e,t)=>{e&&"object"==typeof e&&(o[t]=new f(e,t,a).proxy)}),l=Reflect.apply(r[n],r,o);for(let o,n=0,l=r.length;n<l;n++)(o=r[n])&&"object"==typeof o&&((i=t.get(e.get(o)))?i.ownKey=n:console.error("failed to resolve proxy -> target -> observed"));for(let e=0,t=o.length;e<t;e++)s.push({type:"insert",path:a.path.concat(e),value:r[e]});return p.notify(s),l}:"reverse"===n?function(){let o;Reflect.apply(r[n],r,arguments);for(let n,l=0,a=r.length;l<a;l++)(n=r[l])&&"object"==typeof n&&((o=t.get(e.get(n)))?o.ownKey=l:console.error("failed to resolve proxy -> target -> observed"));return p.notify([{type:"reverse"}]),this}:"sort"===n?function(){let o;Reflect.apply(r[n],r,arguments);for(let n,l=0,a=r.length;l<a;l++)(n=r[l])&&"object"==typeof n&&((o=t.get(e.get(n)))?o.ownKey=l:console.error("failed to resolve proxy -> target -> observed"));return p.notify([{type:"shuffle"}]),this}:"fill"===n?function(){let o,l,i,s=[],y=arguments.length,c=r.length;o=y<2?0:arguments[1]<0?c+arguments[1]:arguments[1],l=y<3?c:arguments[2]<0?c+arguments[2]:arguments[2],i=r.slice(),Reflect.apply(r[n],r,arguments);for(let n,p,y=o;y<l;y++)(n=r[y])&&"object"==typeof n&&(r[y]=new f(n,y,a).proxy),i.hasOwnProperty(y)?((p=e.get(i[y]))&&t.get(p).revoke(),s.push({type:"update",path:a.path.concat(y),value:r[y],oldValue:p||i[y]})):s.push({type:"insert",path:a.path.concat(y),value:r[y]});return p.notify(s),this}:"splice"===n?function(){let o,l,i,s,y,c,h,u,g=[],b=r.length;h=(o=Array.from(arguments)).length;for(let e,t=0;t<h;t++)e=o[t],t>1&&e&&"object"==typeof e&&(o[t]=new f(e,t,a).proxy);s=0===h?0:o[0]<0?b+o[0]:o[0],y=h<2?b-s:o[1],c=Math.max(h-2,0),l=Reflect.apply(r[n],r,o),b=r.length;for(let o,n=0;n<b;n++)(o=r[n])&&"object"==typeof o&&((i=t.get(e.get(o)))?i.ownKey=n:console.error("failed to resolve proxy -> target -> observed"));for(let o,r,n=0,a=l.length;n<a;n++)o=l[n],(r=e.get(o))&&(t.get(r).revoke(),l[n]=r);for(u=0;u<y;u++)u<c?g.push({type:"update",path:a.path.concat(s+u),value:r[s+u],oldValue:l[u]}):g.push({type:"delete",path:a.path.concat(s+u),oldValue:l[u]});for(;u<c;u++)g.push({type:"insert",path:a.path.concat(s+u),value:r[s+u]});return p.notify(g),l}:Reflect.get(r,n)}function a(r,l,a){let p,i=r[l],s=t.get(r),y=o.get(s.root);if(p=a&&"object"==typeof a&&!n(a)?new f(a,l,s).proxy:a,r[l]=p,i){let o=e.get(i);o&&(t.get(o).revoke(),i=o)}if(y.hasListeners()&&!s.preventCallbacks){let e,t=s.path,o=t.length,r=new Array(o+1);for(e=0;e<o;e++)r[e]=t[e];r[o]=l,y.notify([void 0!==i?{type:"update",path:r,value:a,oldValue:i}:{type:"insert",path:r,value:a}])}return!0}function p(r,n){let l,a=r[n],p=t.get(r),f=o.get(p.root);if(l=delete r[n]){if(a){let o=e.get(a);o&&(t.get(o).revoke(),a=o)}if(f.hasListeners()&&!p.preventCallbacks){let e,t=p.path,o=t.length,r=new Array(o+1);for(e=0;e<o;e++)r[e]=t[e];r[o]=n,f.notify([{type:"delete",path:r,oldValue:a}])}}return l}function f(o,r,i){let s;var y;Array.isArray(o)?(function(e,t){let o,r=0,l=e.length;for(;r<l;r++)(o=e[r])&&"object"==typeof o&&!n(o)&&(e[r]=new f(o,r,t).proxy)}(s=function(e){let t=0,o=e.length,r=new Array(o);for(;t<o;t++)r[t]=e[t];return r}(o),this),this.revokable=Proxy.revocable(s,{set:a,get:l,deleteProperty:p})):(y=o,function(e,t){let o,r,l=Object.keys(e),a=l.length;for(;a--;)(r=e[o=l[a]])&&"object"==typeof r&&!n(r)&&(e[o]=new f(r,o,t).proxy)}(s=Object.assign({},y),this),this.revokable=Proxy.revocable(s,{set:a,deleteProperty:p})),this.targetClone=s,this.proxy=this.revokable.proxy,this.ownKey=r,this.parent=i,t.set(s,this),e.set(this.proxy,s)}function i(e){let t=!1,o=[];Object.defineProperties(e.targetClone,{observe:{value:function(e){if(t)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");o.indexOf(e)<0?o.push(e):console.info("observer (callback) may be bound to an observable only once")}},unobserve:{value:function(){if(t)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");if(arguments.length)for(let e,t=0,r=arguments.length;t<r;t++)(e=o.indexOf(arguments[t]))>=0&&o.splice(e,1);else o.splice(0,o.length)}},revoke:{value:function(){t?console.log("revoking of Observable effective only once"):(t=!0,e.revoke())}}}),this.hasListeners=function(){return o.length>0},this.notify=function(e){let t=o.length;for(;t--;)try{o[t](e)}catch(e){console.error("one/some of the observing callbacks failed with ",e)}}}module.exports=i,Object.defineProperty(f.prototype,"root",{get:function(){let e=this;for(;e.parent;)e=e.parent;return e}}),Object.defineProperty(f.prototype,"path",{get:function(){let e=[],t=[],o=0,r=0,n=this;for(;void 0!==n.ownKey;)e[o++]=n.ownKey,n=n.parent;for(;o--;)t[r++]=e[o];return t}}),Object.defineProperty(f.prototype,"revoke",{value:function(){let o=e.get(this.proxy),r=Object.keys(o);this.revokable.revoke();for(let n,l,a=0,p=r.length;a<p;a++)n=r[a],(l=e.get(o[n]))&&(o[n]=t.get(l).revoke());return e.delete(this.proxy),t.delete(o),o}}),Object.defineProperty(i,"from",{value:function(e){if(!(!e||"object"!=typeof e||n(e)||"observe"in e||"unobserve"in e||"revoke"in e)){let t=new f(e),r=new i(t);return o.set(t,r),t.proxy}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(n(e))throw new Error(e+" found to be one of non-observable object types: "+r)}}),Object.freeze(i);