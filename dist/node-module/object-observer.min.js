const proxiesToTargetsMap=new Map,targetsToObserved=new Map,observedToObservable=new Map,nonObservables=["Date","Blob","Number","String","Boolean","Error","SyntaxError","TypeError","URIError","Function","Promise","RegExp"];function copyShallow(e){return Array.isArray(e)?e.slice():Object.assign({},e)}function isNonObservable(e){return nonObservables.indexOf(e.constructor.name)>=0}function proxiedArrayGet(e,t){let r,o=targetsToObserved.get(e),n=observedToObservable.get(o.root);return r="pop"===t?function(){let r,s,a;return r=e.length-1,s=Reflect.apply(e[t],e,arguments),(a=proxiesToTargetsMap.get(s))&&targetsToObserved.get(a).revoke(),n.notify([new DeleteChange(o.path.concat(r),a||s)]),a||s}:"push"===t?function(){let r,s,a,l=[];r=Array.from(arguments),a=e.length;for(let e,t=0,n=r.length;t<n;t++)(e=r[t])&&"object"==typeof e&&(r[t]=new Observed(e,a+t,o).proxy),l.push(new InsertChange(o.path.concat(a+t),e));return s=Reflect.apply(e[t],e,r),n.notify(l),s}:"shift"===t?function(){let r,s;r=Reflect.apply(e[t],e,arguments),(s=proxiesToTargetsMap.get(r))&&targetsToObserved.get(s).revoke();for(let t,r,o=0,n=e.length;o<n;o++)(t=e[o])&&"object"==typeof t&&((r=targetsToObserved.get(proxiesToTargetsMap.get(t)))?r.ownKey=o:console.error("unexpectedly failed to resolve proxy -> target -> observed"));return n.notify([new DeleteChange(o.path.concat(0),s||r)]),s||r}:"unshift"===t?function(){let r,s,a,l=[];(r=Array.from(arguments)).forEach(function(e,t){e&&"object"==typeof e&&(r[t]=new Observed(e,t,o).proxy)}),s=Reflect.apply(e[t],e,r);for(let t,r=0,o=e.length;r<o;r++)(t=e[r])&&"object"==typeof t&&((a=targetsToObserved.get(proxiesToTargetsMap.get(t)))?a.ownKey=r:console.error("failed to resolve proxy -> target -> observed"));for(let t=0,n=r.length;t<n;t++)l.push(new InsertChange(o.path.concat(t),e[t]));return n.notify(l),s}:"reverse"===t?function(){let r;Reflect.apply(e[t],e,arguments);for(let t,o=0,n=e.length;o<n;o++)(t=e[o])&&"object"==typeof t&&((r=targetsToObserved.get(proxiesToTargetsMap.get(t)))?r.ownKey=o:console.error("failed to resolve proxy -> target -> observed"));return n.notify([new ReverseChange]),this}:"sort"===t?function(){let r;Reflect.apply(e[t],e,arguments);for(let t,o=0,n=e.length;o<n;o++)(t=e[o])&&"object"==typeof t&&((r=targetsToObserved.get(proxiesToTargetsMap.get(t)))?r.ownKey=o:console.error("failed to resolve proxy -> target -> observed"));return n.notify([new ShuffleChange]),this}:"fill"===t?function(){let r,s,a,l=[],p=arguments.length,i=e.length;r=p<2?0:arguments[1]<0?i+arguments[1]:arguments[1],s=p<3?i:arguments[2]<0?i+arguments[2]:arguments[2],a=e.slice(),Reflect.apply(e[t],e,arguments);for(let t,n,p=r;p<s;p++)(t=e[p])&&"object"==typeof t&&(e[p]=new Observed(t,p,o).proxy),a.hasOwnProperty(p)?((n=proxiesToTargetsMap.get(a[p]))&&targetsToObserved.get(n).revoke(),l.push(new UpdateChange(o.path.concat(p),e[p],n||a[p]))):l.push(new InsertChange(o.path.concat(p),e[p]));return n.notify(l),this}:"splice"===t?function(){let r,s,a,l,p,i,b,f,c=[],v=e.length;b=(r=Array.from(arguments)).length;for(let e,t=0;t<b;t++)e=r[t],t>1&&e&&"object"==typeof e&&(r[t]=new Observed(e,t,o).proxy);l=0===b?0:r[0]<0?v+r[0]:r[0],p=b<2?v-l:r[1],i=Math.max(b-2,0),s=Reflect.apply(e[t],e,r);for(let t,r=0;r<v;r++)(t=e[r])&&"object"==typeof t&&((a=targetsToObserved.get(proxiesToTargetsMap.get(t)))?a.ownKey=r:console.error("failed to resolve proxy -> target -> observed"));for(let e,t,r=0,o=s.length;r<o;r++)e=s[r],(t=proxiesToTargetsMap.get(e))&&(targetsToObserved.get(t).revoke(),s[r]=t);for(f=0;f<p;f++)f<i?c.push(new UpdateChange(o.path.concat(l+f),e[l+f],s[f])):c.push(new DeleteChange(o.path.concat(l+f),s[f]));for(;f<i;f++)c.push(new InsertChange(o.path.concat(l+f),e[l+f]));return n.notify(c),s}:Reflect.get(e,t)}function proxiedSet(e,t,r){let o,n,s=e.hasOwnProperty(t),a=e[t],l=targetsToObserved.get(e),p=observedToObservable.get(l.root);if((o=r&&"object"==typeof r&&!isNonObservable(r)?Reflect.set(e,t,new Observed(r,t,l).proxy):Reflect.set(e,t,r))&&((n=proxiesToTargetsMap.get(a))&&targetsToObserved.get(n).revoke(),p.hasListeners()&&!l.preventCallbacks)){let e=l.path.concat(t);p.notify([s?new UpdateChange(e,r,n||a):new InsertChange(e,r)])}return o}function proxiedDelete(e,t){let r,o,n=e[t],s=targetsToObserved.get(e),a=observedToObservable.get(s.root);if((r=Reflect.deleteProperty(e,t))&&((o=proxiesToTargetsMap.get(n))&&targetsToObserved.get(o).revoke(),a.hasListeners()&&!s.preventCallbacks)){let e=s.path.concat(t);a.notify([new DeleteChange(e,o||n)])}return r}function processArraySubgraph(e,t){for(let r,o=0,n=e.length;o<n;o++)(r=e[o])&&"object"==typeof r&&!isNonObservable(r)&&(e[o]=new Observed(r,o,t).proxy)}function processObjectSubgraph(e,t){let r=Object.keys(e);for(let o,n,s=0,a=r.length;s<a;s++)(n=e[o=r[s]])&&"object"==typeof n&&!isNonObservable(n)&&(e[o]=new Observed(n,o,t).proxy)}function Observed(e,t,r){let o,n,s;if(!e||"object"!=typeof e)throw new Error("Observed MUST be created from a non null object origin");if(r&&(void 0===t||null===t))throw new Error("any non-root (parent-less) Observed MUST have an own path; now parent is "+r+"; key is "+t);if(r&&!(r instanceof Observed))throw new Error("parent, when supplied, MUST be an instance of Observed");o=copyShallow(e),Array.isArray(o)?(processArraySubgraph(o,this),n=Proxy.revocable(o,{set:proxiedSet,get:proxiedArrayGet,deleteProperty:proxiedDelete})):(processObjectSubgraph(o,this),n=Proxy.revocable(o,{set:proxiedSet,deleteProperty:proxiedDelete})),s=n.proxy,targetsToObserved.set(o,this),proxiesToTargetsMap.set(s,o),Object.defineProperties(this,{revokable:{value:n},proxy:{value:s},parent:{value:r},ownKey:{value:t,writable:!0}})}function Observable(e){let t=!1,r=[];Object.defineProperties(e.proxy,{observe:{value:function(e){if(t)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");r.indexOf(e)<0?r.push(e):console.info("observer (callback) may be bound to an observable only once")}},unobserve:{value:function(){if(t)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");if(arguments.length)for(let e,t=0,o=arguments.length;t<o;t++)(e=r.indexOf(arguments[t]))>=0&&r.splice(e,1);else r.splice(0,r.length)}},revoke:{value:function(){t?console.log("revoking of Observable effective only once"):(t=!0,e.revoke())}}}),Object.defineProperties(this,{hasListeners:{value:function(){return r.length>0}},notify:{value:function(e){for(let t,o=0,n=r.length;o<n;o++){t=r[o];try{t(e)}catch(e){console.error("one/some of the observing callbacks failed with ",e)}}}}})}function InsertChange(e,t){Object.defineProperties(this,{type:{value:"insert"},path:{value:e},value:{value:t}})}function UpdateChange(e,t,r){Object.defineProperties(this,{type:{value:"update"},path:{value:e},value:{value:t},oldValue:{value:r}})}function DeleteChange(e,t){Object.defineProperties(this,{type:{value:"delete"},path:{value:e},oldValue:{value:t}})}function ReverseChange(){Object.defineProperties(this,{type:{value:"reverse"}})}function ShuffleChange(){Object.defineProperties(this,{type:{value:"shuffle"}})}module.exports=Observable,Object.defineProperty(Observed.prototype,"root",{get:function(){let e=this;for(;e.parent;)e=e.parent;return e}}),Object.defineProperty(Observed.prototype,"path",{get:function(){let e=[],t=this;for(;void 0!==t.ownKey;)e.unshift(t.ownKey),t=t.parent;return e}}),Object.defineProperty(Observed.prototype,"revoke",{value:function(){let e=proxiesToTargetsMap.get(this.proxy),t=Object.keys(e);this.revokable.revoke();for(let r,o,n=0,s=t.length;n<s;n++)r=t[n],(o=proxiesToTargetsMap.get(e[r]))&&(e[r]=targetsToObserved.get(o).revoke());return proxiesToTargetsMap.delete(this.proxy),targetsToObserved.delete(e),e}}),Object.defineProperty(Observable,"from",{value:function(e){if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(isNonObservable(e))throw new Error(e+" found to be one of non-observable object types: "+nonObservables);let t=new Observed(e),r=new Observable(t);return observedToObservable.set(t,r),t.proxy}}),Object.freeze(Observable);