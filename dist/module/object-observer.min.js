const e=new WeakMap,t=new WeakMap,r={Date:!0,Blob:!0,Number:!0,String:!0,Boolean:!0,Error:!0,SyntaxError:!0,TypeError:!0,URIError:!0,Function:!0,Promise:!0,RegExp:!0};export default i;function o(e){return e&&"object"==typeof e&&!r.hasOwnProperty(e.constructor.name)}function n(r,n){let l,a=t.get(r),i=a.getPath(),p=a.observable;return l="pop"===n?function(){let o,l,a;o=r.length-1,l=Reflect.apply(r[n],r,arguments),(a=e.get(l))&&(t.get(a).revoke(),l=a);let s,f=i.length,y=new Array(f+1);for(s=0;s<f;s++)y[s]=i[s];return y[f]=o,p.notify([{type:"delete",path:y,oldValue:l}]),l}:"push"===n?function(){let e,t,l,f,y=arguments.length,h=new Array(y),c=[],b=i.length;t=r.length;for(let e,r=0;r<y;r++){for(o(e=arguments[r])&&(e=new s({target:e,ownKey:t+r,parent:a,observable:p}).proxy),h[r]=e,f=new Array(b+1),l=0;l<b;l++)f[r]=i[l];f[b]=t+r,c[r]={type:"insert",path:f,value:e}}return e=Reflect.apply(r[n],r,h),p.notify(c),e}:"shift"===n?function(){let o,l;o=Reflect.apply(r[n],r,arguments),(l=e.get(o))&&(t.get(l).revoke(),o=l);for(let o,n,l=0,a=r.length;l<a;l++)(o=r[l])&&"object"==typeof o&&((n=t.get(e.get(o)))?n.ownKey=l:console.error("unexpectedly failed to resolve proxy -> target -> observed"));return p.notify([{type:"delete",path:i.concat(0),oldValue:o}]),o}:"unshift"===n?function(){let l,f,y,h=[];(l=Array.from(arguments)).forEach((e,t)=>{o(e)&&(l[t]=new s({target:e,ownKey:t,parent:a,observable:p}).proxy)}),f=Reflect.apply(r[n],r,l);for(let o,n=0,l=r.length;n<l;n++)(o=r[n])&&"object"==typeof o&&((y=t.get(e.get(o)))?y.ownKey=n:console.error("failed to resolve proxy -> target -> observed"));for(let e=0,t=l.length;e<t;e++)h.push({type:"insert",path:i.concat(e),value:r[e]});return p.notify(h),f}:"reverse"===n?function(){let o;Reflect.apply(r[n],r,arguments);for(let n,l=0,a=r.length;l<a;l++)(n=r[l])&&"object"==typeof n&&((o=t.get(e.get(n)))?o.ownKey=l:console.error("failed to resolve proxy -> target -> observed"));return p.notify([{type:"reverse"}]),this}:"sort"===n?function(){let o;Reflect.apply(r[n],r,arguments);for(let n,l=0,a=r.length;l<a;l++)(n=r[l])&&"object"==typeof n&&((o=t.get(e.get(n)))?o.ownKey=l:console.error("failed to resolve proxy -> target -> observed"));return p.notify([{type:"shuffle"}]),this}:"fill"===n?function(){let l,f,y,h=[],c=arguments.length,b=r.length;l=c<2?0:arguments[1]<0?b+arguments[1]:arguments[1],f=c<3?b:arguments[2]<0?b+arguments[2]:arguments[2],y=r.slice(),Reflect.apply(r[n],r,arguments);for(let n,c,b=l;b<f;b++)o(n=r[b])&&(r[b]=new s({target:n,ownKey:b,parent:a,observable:p}).proxy),y.hasOwnProperty(b)?((c=e.get(y[b]))&&t.get(c).revoke(),h.push({type:"update",path:i.concat(b),value:r[b],oldValue:c||y[b]})):h.push({type:"insert",path:i.concat(b),value:r[b]});return p.notify(h),this}:"splice"===n?function(){let l,f,y,h,c,b,u,g,v=[],w=r.length;u=(l=Array.from(arguments)).length;for(let e,t=0;t<u;t++)e=l[t],t>1&&o(e)&&(l[t]=new s({target:e,ownKey:t,parent:a,observable:p}).proxy);h=0===u?0:l[0]<0?w+l[0]:l[0],c=u<2?w-h:l[1],b=Math.max(u-2,0),f=Reflect.apply(r[n],r,l),w=r.length;for(let o,n=0;n<w;n++)(o=r[n])&&"object"==typeof o&&((y=t.get(e.get(o)))?y.ownKey=n:console.error("failed to resolve proxy -> target -> observed"));for(let r,o,n=0,l=f.length;n<l;n++)r=f[n],(o=e.get(r))&&(t.get(o).revoke(),f[n]=o);for(g=0;g<c;g++)g<b?v.push({type:"update",path:i.concat(h+g),value:r[h+g],oldValue:f[g]}):v.push({type:"delete",path:i.concat(h+g),oldValue:f[g]});for(;g<b;g++)v.push({type:"insert",path:i.concat(h+g),value:r[h+g]});return p.notify(v),f}:Reflect.get(r,n)}function l(r,n,l){let a=r[n],i=t.get(r),p=i.observable;if(o(l)?r[n]=new s({target:l,ownKey:n,parent:i,observable:p}).proxy:r[n]=l,a){let r=e.get(a);r&&(t.get(r).revoke(),a=r)}if(p.hasListeners()){let e,t=i.getPath(),r=t.length,o=new Array(r+1);for(e=0;e<r;e++)o[e]=t[e];o[r]=n,p.notify([void 0!==a?{type:"update",path:o,value:l,oldValue:a}:{type:"insert",path:o,value:l}])}return!0}function a(r,o){let n=r[o],l=t.get(r),a=l.observable;if(delete r[o]){if(n){let r=e.get(n);r&&(t.get(r).revoke(),n=r)}if(a.hasListeners()){let e,t=l.getPath(),r=t.length,s=new Array(r+1);for(e=0;e<r;e++)s[e]=t[e];s[r]=o,a.notify([{type:"delete",path:s,oldValue:n}])}return!0}return!1}function s(r){this.ownKey=r.ownKey,this.parent=r.parent,this.observable=r.observable;let o,s=r.target;if(Array.isArray(s)){let e=0,t=s.length;for(o=new Array(t);e<t;e++)o[e]=s[e];this.processArraySubgraph(o),this.revokable=Proxy.revocable(o,{set:l,get:n,deleteProperty:a})}else o=Object.assign({},s),this.processObjectSubgraph(o),this.revokable=Proxy.revocable(o,{set:l,deleteProperty:a});this.proxy=this.revokable.proxy,this.targetClone=o,t.set(o,this),e.set(this.proxy,o)}function i(e){let t,r=!1,o=[];this.getRootProxy=function(){return t.proxy},this.hasListeners=function(){return o.length>0},this.getListeners=function(){return o},this.notify=function(e){let t=o.length;for(;t--;)try{o[t](e)}catch(e){console.error("one/some of the observing callbacks failed with ",e)}},t=new s({target:e,ownKey:null,parent:null,observable:this}),Object.defineProperties(t.targetClone,{observe:{value:function(e){if(r)throw new TypeError("revoked Observable MAY NOT be observed anymore");if("function"!=typeof e)throw new Error("observer (callback) parameter MUST be a function");o.indexOf(e)<0?o.push(e):console.info("observer (callback) may be bound to an observable only once")}},unobserve:{value:function(){if(r)throw new TypeError("revoked Observable MAY NOT be unobserved anymore");if(arguments.length)for(let e,t=0,r=arguments.length;t<r;t++)(e=o.indexOf(arguments[t]))>=0&&o.splice(e,1);else o.splice(0,o.length)}},revoke:{value:function(){r?console.log("revoking of Observable effective only once"):(r=!0,t.revoke())}}})}s.prototype.processObjectSubgraph=function(e){let t,r,n=Object.keys(e),l=n.length,a=this.observable;for(;l--;)o(r=e[t=n[l]])&&(e[t]=new s({target:r,ownKey:t,parent:this,observable:a}).proxy)},s.prototype.processArraySubgraph=function(e){let t,r=0,n=e.length,l=this.observable;for(;r<n;r++)o(t=e[r])&&(e[r]=new s({target:t,ownKey:r,parent:this,observable:l}).proxy)},s.prototype.getPath=function(){let e=[],t=[],r=0,o=0,n=this;for(;null!==n.ownKey;)e[r++]=n.ownKey,n=n.parent;for(;r--;)t[o++]=e[r];return t},s.prototype.revoke=function(){let r=e.get(this.proxy),o=Object.keys(r),n=o.length;for(this.revokable.revoke();n--;){let l=o[n],a=e.get(r[l]);a&&(r[l]=t.get(a).revoke())}return e.delete(this.proxy),t.delete(r),r},Object.defineProperty(i,"from",{value:function(e){if(!(!o(e)||"observe"in e||"unobserve"in e||"revoke"in e)){return new i(e).getRootProxy()}if(!e||"object"!=typeof e)throw new Error("observable MAY ONLY be created from non-null object only");if("observe"in e||"unobserve"in e||"revoke"in e)throw new Error('target object MUST NOT have nor own neither inherited properties from the following list: "observe", "unobserve", "revoke"');if(!o(e))throw new Error(e+" found to be one of non-observable object types: "+r)}}),Object.freeze(i);